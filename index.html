<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>手势傅里叶水波交互</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: sans-serif;
        }

        canvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 8px;
            pointer-events: none;
            font-size: 14px;
        }

        video {
            display: none;
        }
    </style>
</head>
<body>

    <div id="info">正在初始化摄像头和手势识别...</div>
    <video id="video" playsinline></video>
    <canvas id="canvas"></canvas>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script id="vs" type="x-shader/x-vertex">
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    </script>

    <script id="fs" type="x-shader/x-fragment">
        precision highp float;
        varying vec2 vUv;
        uniform float time;
        uniform float brightness; // 手部距离映射
        uniform float frequency;  // 手部摆动频率映射

        void main() {
            vec2 uv = vUv * 2.0 - 1.0;
            float wave = 0.0;

            // 模拟多个不同频率的波叠加（傅里叶合成的思想）
            for(float i = 1.0; i < 6.0; i++) {
                wave += sin(uv.x * i * 5.0 * frequency + time * i) * (0.2 / i);
                wave += cos(uv.y * i * 3.0 * frequency + time * 0.5 * i) * (0.1 / i);
            }

            // 颜色计算
            vec3 baseColor = vec3(0.1, 0.4, 0.8); // 深蓝色水底
            vec3 highlight = vec3(0.5, 0.9, 1.0); // 亮色波峰

            vec3 color = mix(baseColor, highlight, wave + 0.5);
            color *= brightness; // 亮度受距离控制

            gl_FragColor = vec4(color, 1.0);
        }
    </script>

    <script type="module">
        import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js';

        const videoElement = document.getElementById('video');
        const info = document.getElementById('info');
        let handFrequency = 1.0;
        let handBrightness = 1.0;
        let lastX = 0.5;
        let lastTime = Date.now();

        // --- Three.js 初始化 ---
        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);

        const geometry = new THREE.PlaneGeometry(2, 2);
        const material = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                brightness: { value: 1.0 },
                frequency: { value: 1.0 }
            },
            vertexShader: document.getElementById('vs').textContent,
            fragmentShader: document.getElementById('fs').textContent
        });
        const mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);

        // --- 手势识别逻辑 ---
        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults((results) => {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const hand = results.multiHandLandmarks[0];

                // 1. 亮度映射：利用食指指尖(8)和手掌根部(0)的相对大小来估算距离
                // 在2D画面中，手掌占比越大，认为离摄像头越近
                const dx = hand[8].x - hand[0].x;
                const dy = hand[8].y - hand[0].y;
                const distance = Math.sqrt(dx*dx + dy*dy);
                // 距离感应：通常 0.1(远) 到 0.5(近)，映射到亮度
                handBrightness = THREE.MathUtils.mapLinear(distance, 0.1, 0.5, 0.2, 2.5);

                // 2. 频率映射：计算水平移动速度
                const currentX = hand[9].x; // 中指根部
                const currentTime = Date.now();
                const deltaX = Math.abs(currentX - lastX);
                const deltaTime = (currentTime - lastTime) / 1000;

                if(deltaTime > 0) {
                    const speed = deltaX / deltaTime;
                    // 平滑处理频率变化
                    handFrequency = handFrequency * 0.9 + (1.0 + speed * 2.0) * 0.1;
                }

                lastX = currentX;
                lastTime = currentTime;
                info.innerText = "手势已锁定：挥动改变频率，靠近增强亮度";
            } else {
                info.innerText = "未检测到手部";
                handBrightness *= 0.95; // 失去目标时缓慢变暗
            }
        });

        const cameraTracker = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({ image: videoElement });
            },
            width: 640,
            height: 480
        });
        cameraTracker.start();

        // --- 渲染循环 ---
        function animate() {
            requestAnimationFrame(animate);
            material.uniforms.time.value += 0.02;
            material.uniforms.brightness.value = handBrightness;
            material.uniforms.frequency.value = handFrequency;
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>