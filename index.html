<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fluid Zen Waves</title>
    <style>
        body {
            margin: 0;
            background: #000;
            overflow: hidden;
            font-family: 'Helvetica Neue', sans-serif;
        }

        canvas {
            display: block;
        }

        video {
            display: none;
        }

        #hud {
            position: absolute;
            bottom: 30px;
            left: 30px;
            color: rgba(255,255,255,0.5);
            pointer-events: none;
            font-size: 10px;
            letter-spacing: 2px;
        }
    </style>
</head>
<body>
    <div id="hud">SYSTEM_STATUS: <span id="ui-status">CALIBRATING</span></div>

    <video id="video" playsinline></video>
    <canvas id="canvas"></canvas>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script id="vs" type="x-shader/x-vertex">
        varying vec2 vUv;
        void main() { vUv = uv; gl_Position = vec4(position, 1.0); }
    </script>

    <script id="fs" type="x-shader/x-fragment">
        precision highp float;
        varying vec2 vUv;
        uniform float time;
        uniform float uCount;
        uniform float uFreq;       // 摆动频率增量
        uniform float uComplexity; // 波长复杂度
        uniform float uIntensity;  // 亮度

        void main() {
            vec2 uv = vUv;
            vec2 p = (uv - 0.5) * 2.0;
            p.x *= 1.8;

            float finalOutput = 0.0;

            // 基础时间步进 + 交互频率增量
            // 即使 uFreq 为 0，波也会缓慢游动
            float activeTime = time + uFreq;

            for(float i = 1.0; i <= 10.0; i++) {
                if(i > uCount) break;

                float yOffset = (i / 11.0 - 0.5) * 1.3;

                // 空间扰动保持抽象美感
                float xDistort = p.x + sin(p.y * 1.5 + activeTime * 0.3 + i) * 0.2;
                float yDistort = p.y - yOffset;

                // 核心波动公式：这里控制了波形的形态
                float wavePattern = sin(xDistort * (uComplexity + i * 0.2) + activeTime * 0.8 + i * 2.0);

                // 让波的起伏不要太生硬，乘以 0.12 限制振幅
                float dist = abs(yDistort - wavePattern * 0.12);

                // 线条光晕渲染
                float lineIntensity = 0.004 / (dist + 0.015);
                finalOutput += lineIntensity * uIntensity;
            }

            // 边缘平滑压暗，增加高级感
            float edgeFade = smoothstep(1.2, 0.4, length(p * vec2(0.6, 1.0)));
            gl_FragColor = vec4(vec3(finalOutput * edgeFade), 1.0);
        }
    </script>

    <script type="module">
        import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js';

        let target = { count: 3, freq: 0, complexity: 1.2, intensity: 0.6 };
        let current = { count: 3, freq: 0, complexity: 1.2, intensity: 0.6 };
        let lastX = 0.5, lastTime = Date.now();
        let totalFreqOffset = 0; // 累加频率产生的偏移，确保波动连续

        const scene = new THREE.Scene();
        const camera = new THREE.Camera();
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);

        const material = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                uCount: { value: 3.0 },
                uFreq: { value: 0.0 },
                uComplexity: { value: 1.2 },
                uIntensity: { value: 0.6 }
            },
            vertexShader: document.getElementById('vs').textContent,
            fragmentShader: document.getElementById('fs').textContent,
            blending: THREE.AdditiveBlending,
            transparent: true
        });

        scene.add(new THREE.Mesh(new THREE.PlaneGeometry(2, 2), material));

        const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5 });

        hands.onResults((results) => {
            const statusEl = document.getElementById('ui-status');
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                statusEl.innerText = "ACTIVE_TRACKING";
                const hand = results.multiHandLandmarks[0];
                const dist = Math.hypot(hand[8].x - hand[0].x, hand[8].y - hand[0].y);

                // 距离映射：数量 (1-10)
                target.count = THREE.MathUtils.mapLinear(dist, 0.08, 0.4, 1.5, 10.0);
                target.intensity = THREE.MathUtils.mapLinear(dist, 0.08, 0.4, 0.4, 1.8);

                // 速度映射：通过开方处理减少抖动，让反应更沉稳
                const currX = hand[9].x;
                const dt = (Date.now() - lastTime) / 1000;
                const rawSpeed = Math.abs(currX - lastX) / dt;

                // 使用 Math.sqrt(rawSpeed) 让速度增加变得平滑
                target.freq = Math.sqrt(rawSpeed) * 0.5;
                target.complexity = 1.2 + Math.sqrt(rawSpeed) * 1.5;

                lastX = currX;
                lastTime = Date.now();
            } else {
                statusEl.innerText = "STANDBY";
                target.count = 2.0;
                target.freq = 0.0;
                target.complexity = 1.0;
                target.intensity = 0.4;
            }
        });

        new Camera(document.getElementById('video'), {
            onFrame: async () => { await hands.send({ image: document.getElementById('video') }); },
            width: 640, height: 480
        }).start();

        function animate() {
            requestAnimationFrame(animate);

            // 极慢的插值系数，确保即使手部抖动，视觉上也是平滑流动的
            const lerpStep = 0.04;
            current.count = THREE.MathUtils.lerp(current.count, target.count, lerpStep);
            current.intensity = THREE.MathUtils.lerp(current.intensity, target.intensity, lerpStep);
            current.complexity = THREE.MathUtils.lerp(current.complexity, target.complexity, lerpStep);

            // 频率增量的平滑
            current.freq = THREE.MathUtils.lerp(current.freq, target.freq, lerpStep);
            // 累加时间，使基础波动始终存在
            totalFreqOffset += current.freq * 0.2;

            material.uniforms.time.value += 0.01; // 基础慢速
            material.uniforms.uFreq.value = totalFreqOffset; // 加上手部贡献的偏移
            material.uniforms.uCount.value = current.count;
            material.uniforms.uComplexity.value = current.complexity;
            material.uniforms.uIntensity.value = current.intensity;

            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
